/*
	This is modules.c it contains the modules necessary to complete a3
	for cps 360.
 */


#include <stdio.h>
#include <stdlib.h>

#define MAX  2147483647

/*	checkargs takes 3 parameters, the 1st is an integer that represents the count of 
	arguments entered to the function plus one. the next two arguments are strings 
	that contain the 2 arguments. If the argument count is not 3 the passed arguments
	to the function are invalid and checkargs returns 0. Then the two strings are parsed
	to make sure that they are both numbers, if they are checkargs returns 1, else it 
	returns 0. 
 */
int checkargs(int argc, char* arg1, char* arg2){
	int i;
	if(argc!=3) return 0;
	i=0;
	while(*(arg1+i)){
		if(*(arg1+i)>'9'||*(arg1+i)<'0')return 0;
		i++;
	}
	i=0;
	while(*(arg2+i)){
		if(*(arg2+i)>'9'||*(arg2+i)<'0') return 0;
		i++;
	}
	return 1;
}

/*	fadder is a full adder. it takes 5 inputs. The first 3 are integers that represent
	the bits to be added and the carry in value. the next parameter is the address
	of a long for the returned sum and the last param is an address of an int to return
	the carry out value. fadder adds two bits with any carry in and returns the result
	using boolean logic.
 */
void fadder(int a, int b, int ci, long *res, int *co){
	int carryout,result;
	result=(a ^ b ^ ci)|(a&b&ci);
	carryout=(a&b)|(b&ci)|(a&ci);
	*res=result;
	*co=carryout;
}

/*	rcadder4 implements the fadder function with ripple carry. It has the same 5 inputs
	as fadder except instead of a and b only being 0 or 1, now they can contain values
	valid on 4 bits. First a and b are broken  down into a binary representation
	then the least significant bits are added with the carry in given in the parameters.
	then the carry out of that is plugged in to the next fadder and then a sum is made 
	from the resulting sum bits which is returned in *res, likewise with *co except
	it contains the carryout value
 */
void rcadder4(int a, int b, int ci, long *res, int *co){
	int *abits,*bbits,i,j,carryout;
	unsigned long int result, sum;
	char binstring[5];
	i=0;
	abits=malloc(sizeof(int)*4);
	bbits=malloc(sizeof(int)*4);
	result=0;
	sum=0;
	carryout=ci;
	while(i<4){
		abits[i]=a%2;
		bbits[i]=b%2;
		a/=2;
		b/=2;
		fadder(abits[i],bbits[i],carryout,&result,&carryout);
		binstring[i]=(result+'0');
		i++;
	}
	
	i=1;
	j=0;
	while(j<4){
		sum+=i*(binstring[j]-'0');
		i*=2;
		j++;		
	}
	*res=sum;
	*co=carryout;
}

/*	lacgen4 takes 4 inputs, the 1st 2 are the bits of the integers to be added,
	the next parameter is the address of an array that will contain the carry out
	values and the last parameter is the carry in for the operation. Iteratively using 
	boolean logic the carryouts are generated then returned.
 */

void lacgen4(int *a, int *b,int **c,int ci){
	int i,*carryout;
	carryout=malloc(sizeof(int)*5);
	carryout[0]=ci;
	i=0;
	while(i<4){
	carryout[i+1]=(a[i]&carryout[i])|(b[i]&carryout[i])|(a[i]&b[i]);
	i++;	
	}
	*c=carryout;
}

/*	lacadder4 uses lacgen4 and the fadder functions to perform a 4 bit addition
	with look ahead carry. first the input integers a and b are broken down into
	binary forms then the carryouts are generated by lacgen4. after this the arithmatic
	is done using fadder and the resulting carrys and bits which are stored in an array
	called sumbits. then the sumbits array is used to calculate a sum of the two integers
	a and b which is returned in *res. the carry out is returned in *co.
 */

void lacadder4(int a, int b, int ci, long *res, int *co){
	int *abits,*bbits,*carryins,i,j;
	unsigned long int *sumbits, sum;
	abits=malloc(sizeof(int)*4);
	bbits=malloc(sizeof(int)*4);
	carryins=malloc(sizeof(int)*5);
	sumbits=malloc(sizeof(int)*4);
	i=0;
	while(i<4){
		abits[i]=a%2;
		bbits[i]=b%2;
		a/=2;
		b/=2;
		i++;
	}
	lacgen4(abits,bbits,&carryins,ci);
	fadder(abits[0],bbits[0],carryins[0],&sumbits[0],&i);
	fadder(abits[1],bbits[1],carryins[1],&sumbits[1],&i);
	fadder(abits[2],bbits[2],carryins[2],&sumbits[2],&i);
	fadder(abits[3],bbits[3],carryins[3],&sumbits[3],&i);

	i=1;
	j=0;
	sum=0;
	while(j<4){
		sum+=i*sumbits[j];
		i*=2;
		j++;		
	}
	*res=sum;
	*co= carryins[4];

}

/*
	rcadder32 uses rcadder4 to add 32 bits. first the 32 bit numbers
	a and b are broken into 4 bit chuncks using bit shift operations
	then they are entered iteratively into rcadder4 to do the calculations
	the results are then kept in a sum variable which is returned to *res
	*co also gets the carry out value.
 */

void rcadder32(int a, int b, int ci, long *res, int *co){
	unsigned int abits[8], bbits[8],tempa,tempb,carryout;
	unsigned long int result, sum;
	int i;
	int absolutevalue(int);
	i=0;
	while(i<8){
		tempa=a<<(i*4);
		tempa=tempa>>28;

		tempb=b<<(i*4);
		tempb=tempb>>28;

		tempa=absolutevalue(tempa);
		tempb=absolutevalue(tempb);

		abits[i]=tempa;
		bbits[i]=tempb;
		i++;
	}
	i=7;
	carryout=ci;
	sum=0;
	while(i>=0){
		rcadder4(abits[i],bbits[i],carryout,&result,&carryout);
		sum+=result<<(28-i*4);
		i--;
	}
	*res=sum;
	*co=carryout;
}
/* 	absolutevalue takes an input integer and returns its absolute value
	to do this it checks if the integer is positive or negative. if 
	positive it returns the value, if negative it returns the 2s complement
 */

int absolutevalue(int i){
	if(i<0) i=~i+1;
	return i;
}
/*	converttostring takes a long and the address of a string and converts
	a binary number into a string which is returned in *c.
 */
void converttostring(unsigned long num, char **c){
	char *s,*r;
	s=malloc(10);
	s = "4294967296";
	r=malloc(10);
	int i,ci;
	i=0;
	ci=0;
	while (i<10){
		if(*(s+(9-i))-'0'+ci+num%10<10){
			r[9-i]=(*(s+(9-i))-'0')+num%10+ci+'0';
			ci=0;		
		}
		else{
			r[9-i]=((*(s+(9-i))-'0')+num%10+ci)%10+'0';
			ci=1;
		}
		num/=10;
		i++;
	}
	*c = r;
}
/*	same idea as lacgen4 but for the 32 bit version.
 */
void lacgen32(int *a, int *b, int **c, int ci){
	int i,*carryout;
	carryout=malloc(sizeof(int)*9);
	carryout[0]=ci;
	i=0;
	while(i<8){
		carryout[i+1]=(a[7-i]+b[7-i]+carryout[i])>=16;
		i++;
	}
	*c=carryout;
}

/*	lacadder32 adds two 32 bit numbers using look ahead carry
	this is done by breaking the numbers into 4 bit chunks and 
	then feeding them to lacadder4. then the sum is calculated and
	returned in *res, the carryout is returned in *co
 */
void lacadder32(int a, int b, int ci, long *res, int *co){
	unsigned int abits[8], bbits[8],tempa,tempb;
	unsigned long int result, sum;
	int i,*carryins;
	int absolutevalue(int);
	i=0;
	while(i<8){
		tempa=a<<(i*4);
		tempa=tempa>>28;

		tempb=b<<(i*4);
		tempb=tempb>>28;

		tempa=absolutevalue(tempa);
		tempb=absolutevalue(tempb);

		abits[i]=tempa;
		bbits[i]=tempb;
		i++;
	}
	sum=0;
	lacgen32(abits,bbits,&carryins,ci);
	lacadder4(abits[0],bbits[0],carryins[7],&result,&i);
	sum+=result<<28;
	lacadder4(abits[1],bbits[1],carryins[6],&result,&i);
	sum+=result<<24;
	lacadder4(abits[2],bbits[2],carryins[5],&result,&i);
	sum+=result<<20;
	lacadder4(abits[3],bbits[3],carryins[4],&result,&i);
	sum+=result<<16;
	lacadder4(abits[4],bbits[4],carryins[3],&result,&i);
	sum+=result<<12;
	lacadder4(abits[5],bbits[5],carryins[2],&result,&i);
	sum+=result<<8;
	lacadder4(abits[6],bbits[6],carryins[1],&result,&i);
	sum+=result<<4;
	lacadder4(abits[7],bbits[7],carryins[0],&result,&i);
	sum+=result;
	*res=sum;
	*co=carryins[8];
}
/*	converts the int n to a binary string which is returned in *res
 */
void inttobinary(int n, char **result){
	void reversestr(char**);
	char* binary,*temp;
	int i;
	binary=malloc(33);
	temp=binary;
	i=0;
	while(n>0){
		temp[i]=n%2+'0';
		n/=2;
		i++;
	}
	temp[i]=0;
	reversestr(&binary);
	*result=binary;
}
/*	used by inttobinary to get the correct binary string
	it takes the input string and returns it except in reverse order.
 */
void reversestr(char **str){
	int i,j;
	i=0;
	char *result;
	result=malloc(sizeof(*str));
	while(*(*(str)+i)){
		i++;
	}
	i--;
	j=0;
	while(i>=0){
		result[j]=*(*(str)+i);
		i--;
		j++;
	}
	result[j]=0;
	*str=result;
}
